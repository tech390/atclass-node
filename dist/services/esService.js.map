{"version":3,"sources":["../../src/services/esService.js"],"names":["ESService","id","context","index","type","existingIndex","indexBody","JSON","parse","stringify","getESExists","existingIndexData","getESData","_source","err","Log","child","message","stack","error","Promise","reject","getIndexData","client","get","exists","body","data","indexDataArr","results","indexData","push","all","Object","entries","length","result","indices","delete","reindex","bulkindexData","bulkResponse","bulk","refresh","errors","erroredDocuments","items","forEach","action","i","operation","keys","status","search","hits","map","x","resolve","getMapping","updateByQuery","esService"],"mappings":"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","file":"esService.js","sourcesContent":["import { client } from '../db/esclient';\r\nimport {\r\n    Log\r\n} from '../services';\r\n\r\nexport class ESService {\r\n\r\n    async checkExistingDataIndex(id, context, index, type) {\r\n\r\n        let existingIndex = {};\r\n        let indexBody = JSON.parse(JSON.stringify(context));\r\n        try {\r\n            existingIndex = await this.getESExists(index, type, id);\r\n            if (existingIndex) {\r\n\r\n                const existingIndexData = await this.getESData(index, type, id);\r\n                if (existingIndexData) {\r\n                    indexBody = {\r\n                        id: id,\r\n                        _source: existingIndexData._source\r\n                    };\r\n                }\r\n            }\r\n\r\n            return indexBody;\r\n        } catch (err) {\r\n            Log.child({\r\n                message: err.message,\r\n                stack: err.stack\r\n            }).error('Error running checkExistingGridIndex. See Log.child.errorMessage.');\r\n\r\n            return Promise.reject(err);\r\n        }\r\n    }\r\n\r\n    async getESData(index, type, id) {\r\n        try {\r\n            const getIndexData = await client.get({\r\n                index: index,\r\n                type: type,\r\n                id: id\r\n            });\r\n            return getIndexData;\r\n\r\n        } catch (err) {\r\n            Log.child({\r\n                message: err.message,\r\n                stack: err.stack\r\n            }).error('Error running getESData. See Log.child.errorMessage.');\r\n\r\n\r\n            return Promise.reject(err);\r\n        }\r\n    }\r\n\r\n    async getESExists(index, type, id) {\r\n        try {\r\n            const existingIndex = await client.exists({\r\n                index: index,\r\n                type: type,\r\n                id: id\r\n            });\r\n            return existingIndex;\r\n\r\n        } catch (err) {\r\n            Log.child({\r\n                message: err.message,\r\n                stack: err.stack\r\n            }).error('Error running getESExists. See Log.child.errorMessage.');\r\n\r\n            return Promise.reject(err);\r\n        }\r\n    }\r\n\r\n    prepareIndexData(index, type, id, body) {\r\n        const data = {\r\n            index: index,\r\n            type: type,\r\n            id: id,\r\n            body: body\r\n        };\r\n\r\n        return data;\r\n    }\r\n\r\n    async indexDataArr(indexDataArr) {\r\n\r\n        try {\r\n            const results = [];\r\n            for (let indexData of indexDataArr) {\r\n                results.push(this.indexData(indexData));\r\n            }\r\n            await Promise.all(results);\r\n        } catch (err) {\r\n            Log.child({\r\n                message: err.message,\r\n                stack: err.stack\r\n            }).error('Error running indexDataArr . See Log.child.errorMessage.');\r\n\r\n        }\r\n\r\n    }\r\n\r\n    async indexData(indexData) {\r\n\r\n        try {\r\n            if (Object.entries(indexData).length === 0) {\r\n                return null;\r\n            } else {\r\n                const result = await client.index(indexData);\r\n                return result;\r\n            }\r\n        } catch (err) {\r\n            Log.child({\r\n                message: err.message,\r\n                stack: err.stack\r\n            }).error(`Error running indexData for  ${indexData.index} and ${indexData.id} . See Log.child.errorMessage. ${err}`);\r\n            return {};\r\n        }\r\n\r\n    }\r\n\r\n    async deleteIndex(index) {\r\n        try {\r\n            const result = await client.indices.delete({\r\n                index\r\n            });\r\n            return result;\r\n        } catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    async refreshIndex(index) {\r\n        const result = await client.reindex(index);\r\n        return result;\r\n    }\r\n\r\n    async bulkIndex(bulkindexData) {\r\n        try {\r\n            const bulkResponse = await client.bulk({\r\n                refresh: false,\r\n                body: bulkindexData\r\n            });\r\n            // console.log(JSON.stringify(bulkResponse, undefined, 2));\r\n            if (bulkResponse.errors) {\r\n                const erroredDocuments = [];\r\n                bulkResponse.items.forEach((action, i) => {\r\n                    const operation = Object.keys(action)[0];\r\n                    if (action[operation].error) {\r\n                        erroredDocuments.push({\r\n                            status: action[operation].status,\r\n                            error: action[operation].error,\r\n                            operation: bulkindexData[i * 2]\r\n                        });\r\n                    }\r\n                });\r\n                Log.child({\r\n                    erroredDocuments: erroredDocuments\r\n                }).error('AtClass: bulkIndex erroredDocuments');\r\n                return erroredDocuments;\r\n            }\r\n            return true;\r\n        } catch (error) {\r\n            Log.child({\r\n                message: error.message,\r\n                stack: error.stack\r\n            }).error('AtClass: Error in bulkIndex');\r\n            return error;\r\n        }\r\n    }\r\n\r\n    async search(index, body) {\r\n        try {\r\n            const data = await client.search({\r\n                index,\r\n                body\r\n            });\r\n            return data;\r\n        } catch (error) {\r\n            Log.child({\r\n                message: error.message,\r\n                stack: error.stack\r\n            }).error('AtClass: Error in ES search');\r\n            return error;\r\n        }\r\n    }\r\n\r\n    async searchAndFilterHits(index, body) {\r\n        try {\r\n            const data = await client.search({\r\n                index,\r\n                body\r\n            });\r\n            return data.hits.hits.map(x => x._source);\r\n        } catch (error) {\r\n            Log.child({\r\n                message: error.message,\r\n                stack: error.stack\r\n            }).error('AtClass: Error in ES search');\r\n            return error;\r\n        }\r\n    }\r\n\r\n    async getSchema(index) {\r\n        try {\r\n            return await new Promise((resolve, reject) => {\r\n                client.indices.getMapping({\r\n                    index\r\n                }, (error, data) => {\r\n                    resolve(data);\r\n                });\r\n            });\r\n        } catch (error) {\r\n            return error;\r\n        }\r\n    }\r\n\r\n    async updateByQuery(index, type, body) {\r\n        try {\r\n            return await client.updateByQuery({\r\n                index: index,\r\n                type: type,\r\n                body: body\r\n            });\r\n        } catch (error) {\r\n            return error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Constructs all the given parameters needed to make a request to Elastic Search. \r\n     * @param {*} payload \r\n     */\r\n}\r\nconst esService = new ESService();\r\nexport {\r\n    esService\r\n};"]}